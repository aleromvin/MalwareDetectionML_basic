# Script for extracting PE header features
# Alexander Romero Vinogradov, <aleromvin@gmail.com>
#
# This script is very closely based on some of the scripts in https://github.com/urwithajit9/ClaMP/tree/master/scripts
# Which were written by Ajit Kumar in python2 (this script is in python3)
# This script extracts the integrated feature set of a given PE file

import pefile
import sys
import math
import yara
import io
import csv

pefile_dir = sys.argv[1]


class PE_Features:

    def __init__(self, source):
        self.source = source
        self.rules = yara.compile(filepath="./scripts/peid.yara")

    # THESE ARE ALL THE INTEGRATED FEATURES

    image_dos_header = [
        "e_cblp",
        "e_cp",
        "e_cparhdr",
        "e_maxalloc",
        "e_sp",
        "e_lfanew"]

    file_header = ["NumberOfSections", "CreationYear"] + ["FH_char" + str(i) for i in range(15)]

    optional_header1 = [
        "MajorLinkerVersion",
        "MinorLinkerVersion",
        "SizeOfCode",
        "SizeOfInitializedData",
        "SizeOfUninitializedData",
        "AddressOfEntryPoint",
        "BaseOfCode",
        "BaseOfData",
        "ImageBase",
        "SectionAlignment",
        "FileAlignment",
        "MajorOperatingSystemVersion",
        "MinorOperatingSystemVersion",
        "MajorImageVersion",
        "MinorImageVersion",
        "MajorSubsystemVersion",
        "MinorSubsystemVersion",
        "SizeOfImage",
        "SizeOfHeaders",
        "CheckSum",
        "Subsystem"]

    optional_header_dll_char = ["OH_DLLchar" + str(i) for i in range(11)]

    optional_header2 = [
        "SizeOfStackReserve",
        "SizeOfStackCommit",
        "SizeOfHeapReserve",
        "SizeOfHeapCommit",
        "LoaderFlags"]  # boolean check for zero or not

    optional_header = optional_header1 + optional_header_dll_char + optional_header2

    derived_header = ["sus_sections", "non_sus_sections", "packer", "packer_type", "E_text", "E_data", "filesize",
                      "E_file", "fileinfo"]

    #######################################

    # Auxiliary methods

    def file_creation_year(self, seconds):
        tmp = 1970 + ((int(seconds) / 86400) / 365)
        return int(tmp in range(1980, 2016))

    def file_header_Char_boolean_set(self, pe):
        tmp = [pe.FILE_HEADER.IMAGE_FILE_RELOCS_STRIPPED,
               pe.FILE_HEADER.IMAGE_FILE_EXECUTABLE_IMAGE,
               pe.FILE_HEADER.IMAGE_FILE_LINE_NUMS_STRIPPED,
               pe.FILE_HEADER.IMAGE_FILE_LOCAL_SYMS_STRIPPED,
               pe.FILE_HEADER.IMAGE_FILE_AGGRESIVE_WS_TRIM,
               pe.FILE_HEADER.IMAGE_FILE_LARGE_ADDRESS_AWARE,
               pe.FILE_HEADER.IMAGE_FILE_BYTES_REVERSED_LO,
               pe.FILE_HEADER.IMAGE_FILE_32BIT_MACHINE,
               pe.FILE_HEADER.IMAGE_FILE_DEBUG_STRIPPED,
               pe.FILE_HEADER.IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP,
               pe.FILE_HEADER.IMAGE_FILE_NET_RUN_FROM_SWAP,
               pe.FILE_HEADER.IMAGE_FILE_SYSTEM,
               pe.FILE_HEADER.IMAGE_FILE_DLL,
               pe.FILE_HEADER.IMAGE_FILE_UP_SYSTEM_ONLY,
               pe.FILE_HEADER.IMAGE_FILE_BYTES_REVERSED_HI]
        return [int(s) for s in tmp]

    def optional_header_DLLChar(self, pe):
        tmp = [pe.OPTIONAL_HEADER.IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE,
               pe.OPTIONAL_HEADER.IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY,
               pe.OPTIONAL_HEADER.IMAGE_DLLCHARACTERISTICS_NX_COMPAT,
               pe.OPTIONAL_HEADER.IMAGE_DLLCHARACTERISTICS_NO_ISOLATION,
               pe.OPTIONAL_HEADER.IMAGE_DLLCHARACTERISTICS_NO_SEH,
               pe.OPTIONAL_HEADER.IMAGE_DLLCHARACTERISTICS_NO_BIND,
               pe.OPTIONAL_HEADER.IMAGE_DLLCHARACTERISTICS_WDM_DRIVER,
               pe.OPTIONAL_HEADER.IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE,
               pe.OPTIONAL_HEADER.IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA,
               pe.OPTIONAL_HEADER.IMAGE_DLLCHARACTERISTICS_APPCONTAINER,
               pe.OPTIONAL_HEADER.IMAGE_DLLCHARACTERISTICS_GUARD_CF]
        return [int(s) for s in tmp]

    def optional_header_ImageBase(self, imageBase):
        result = 0
        if imageBase % (64 * 1024) == 0 and imageBase in [268435456, 65536, 4194304]:
            result = 1
        return result

    def optional_header_SectionAlignment(self, sectionAlignment, fileAlignment):
        return int(sectionAlignment >= fileAlignment)

    def optional_header_FileAlignment(self, sectionAlignment, fileAlignment):
        result = 0
        if sectionAlignment >= 512:
            if fileAlignment % 2 == 0 and fileAlignment in range(512, 65537):
                result = 1
        else:
            if fileAlignment == sectionAlignment:
                result = 1
        return result

    def optional_header_SizeOfImage(self, sizeOfImage, sectionAlignment):
        return int(sizeOfImage % sectionAlignment == 0)

    def optional_header_SizeOfHeaders(self, sizeOfHeaders, fileAlignment):
        return int(sizeOfHeaders % fileAlignment == 0)

    def extract_dos_header(self, pe):
        image_dos_header_data = [0 for i in range(6)]
        try:
            image_dos_header_data = [
                pe.DOS_HEADER.e_cblp,
                pe.DOS_HEADER.e_cp,
                pe.DOS_HEADER.e_cparhdr,
                pe.DOS_HEADER.e_maxalloc,
                pe.DOS_HEADER.e_sp,
                pe.DOS_HEADER.e_lfanew]
        except Exception as e:
            print(e)
        return image_dos_header_data

    def extract_file_header(self, pe):
        file_header_data = [0 for i in range(3)]
        file_header_char = []
        try:
            file_header_data = [
                pe.FILE_HEADER.NumberOfSections,
                self.file_creation_year(pe.FILE_HEADER.TimeDateStamp)]
            file_header_char = self.file_header_Char_boolean_set(pe)
        except Exception as e:
            print(e)
        return file_header_data + file_header_char

    def extract_optional_header(self, pe):
        optional_header_data = [0 for i in range(21)]
        dll_char = []
        optional_header_data2 = [0 for i in range(6)]

        try:
            optional_header_data = [
                pe.OPTIONAL_HEADER.MajorLinkerVersion,
                pe.OPTIONAL_HEADER.MinorLinkerVersion,
                pe.OPTIONAL_HEADER.SizeOfCode,
                pe.OPTIONAL_HEADER.SizeOfInitializedData,
                pe.OPTIONAL_HEADER.SizeOfUninitializedData,
                pe.OPTIONAL_HEADER.AddressOfEntryPoint,
                pe.OPTIONAL_HEADER.BaseOfCode,
                pe.OPTIONAL_HEADER.BaseOfData,
                # Check the ImageBase for the condition
                self.optional_header_ImageBase(pe.OPTIONAL_HEADER.ImageBase),
                # Checking for SectionAlignment condition
                self.optional_header_SectionAlignment(pe.OPTIONAL_HEADER.SectionAlignment,
                                                      pe.OPTIONAL_HEADER.FileAlignment),
                # Checking for FileAlignment condition
                self.optional_header_FileAlignment(pe.OPTIONAL_HEADER.SectionAlignment,
                                                   pe.OPTIONAL_HEADER.FileAlignment),
                pe.OPTIONAL_HEADER.MajorOperatingSystemVersion,
                pe.OPTIONAL_HEADER.MinorOperatingSystemVersion,
                pe.OPTIONAL_HEADER.MajorImageVersion,
                pe.OPTIONAL_HEADER.MinorImageVersion,
                pe.OPTIONAL_HEADER.MajorSubsystemVersion,
                pe.OPTIONAL_HEADER.MinorSubsystemVersion,
                # Checking size of Image
                self.optional_header_SizeOfImage(pe.OPTIONAL_HEADER.SizeOfImage, pe.OPTIONAL_HEADER.SectionAlignment),
                # Checking for size of headers
                self.optional_header_SizeOfHeaders(pe.OPTIONAL_HEADER.SizeOfHeaders, pe.OPTIONAL_HEADER.FileAlignment),
                pe.OPTIONAL_HEADER.CheckSum,
                pe.OPTIONAL_HEADER.Subsystem]

            dll_char = self.optional_header_DLLChar(pe)

            optional_header_data2 = [
                pe.OPTIONAL_HEADER.SizeOfStackReserve,
                pe.OPTIONAL_HEADER.SizeOfStackCommit,
                pe.OPTIONAL_HEADER.SizeOfHeapReserve,
                pe.OPTIONAL_HEADER.SizeOfHeapCommit,
                int(pe.OPTIONAL_HEADER.LoaderFlags == 0)]
        except Exception as e:
            print(e)
        return optional_header_data + dll_char + optional_header_data2

    def get_count_suspicious_sections(self, pe):
        tmp = []
        benign_sections = {'.text', '.data', '.rdata', '.idata', '.edata', '.rsrc', '.bss', '.crt', '.tls'}
        for section in pe.sections:
            tmp.append(section.Name.decode("utf8").split('\x00')[0])
        non_sus_sections = len(set(tmp).intersection(benign_sections))
        result = [len(tmp) - non_sus_sections, non_sus_sections]
        return result

    def check_packer(self, filepath):
        result = []
        matches = self.rules.match(filepath)
        # print(matches)
        if not matches:
            result.append([0, "NoPacker"])
        else:
            result.append([1, matches[0]])
        return result

    def get_text_data_entropy(self, pe):
        result = [0.0, 0.0]
        for section in pe.sections:
            s_name = section.Name.decode("utf8").split('\x00')[0]
            if s_name == ".text":
                result[0] = section.get_entropy()
            elif s_name == ".data":
                result[1] = section.get_entropy()
            else:
                pass
        return result

    def get_file_bytes_size(self, filepath):
        with open(filepath, "rb") as f:
            byteArr = list(f.read())
        fileSize = len(byteArr)
        return byteArr, fileSize

    def cal_byteFrequency(self, byteArr, fileSize):
        freqList = []
        for b in range(256):
            ctr = 0
            for byte in byteArr:
                if byte == b:
                    ctr += 1
            freqList.append(float(ctr) / fileSize)
        return freqList

    def get_file_entropy(self, filepath):
        byteArr, fileSize = self.get_file_bytes_size(filepath)
        freqList = self.cal_byteFrequency(byteArr, fileSize)
        # Shannon entropy
        ent = 0.0
        for freq in freqList:
            if freq > 0:
                ent += -freq * math.log(freq, 2)
        return [fileSize, ent]

    def get_fileinfo(self, pe):
        try:
            fileVersion = pe.FileInfo[0].StringTable[0].entries['FileVersion']
            productVersion = pe.FileInfo[0].StringTable[0].entries['ProductVersion']
            productName = pe.FileInfo[0].StringTable[0].entries['ProductName']
            companyName = pe.FileInfo[0].StringTable[0].entries['CompanyName']
            fileVersionLS = pe.VS_FIXEDFILEINFO.FileVersionLS
            fileVersionMS = pe.VS_FIXEDFILEINFO.FileVersionMS
            productVersionLS = pe.VS_FIXEDFILEINFO.ProductVersionLS
            productVersionMS = pe.VS_FIXEDFILEINFO.ProductVersionMS
        except Exception as e:
            result = ["error"]
        else:
            FileVersion = (fileVersionMS >> 16, fileVersionMS & 0xFFFF, fileVersionLS >> 16, fileVersionLS & 0xFFFF)
            ProductVersion = (productVersionMS >> 16, productVersionMS & 0xFFFF, productVersionLS >> 16, productVersionLS & 0xFFFF)
            result = [fileVersion, productVersion, productName, companyName]
        return int(result[0] != 'error')

    def extract_all(self, filepath):
        data = []
        try:
            pe = pefile.PE(filepath)
        except Exception as e:
            print("{} while opening {}".format(e, filepath))
        else:
            data += self.extract_dos_header(pe)
            data += self.extract_file_header(pe)
            data += self.extract_optional_header(pe)
            num_ss_nss = self.get_count_suspicious_sections(pe)
            data += num_ss_nss
            packer = self.check_packer(filepath)
            data += packer[0]
            entropy_sections = self.get_text_data_entropy(pe)
            data += entropy_sections
            f_size_entropy = self.get_file_entropy(filepath)
            data += f_size_entropy
            fileinfo = self.get_fileinfo(pe)
            data.append(fileinfo)
        return data

    def create_dataset(self):
        si = io.StringIO()
        cw = csv.writer(si)
        header = self.image_dos_header + self.file_header + self.optional_header + self.derived_header
        data = self.extract_all(self.source)
        cw.writerow(header)
        cw.writerow(data)
        return si.getvalue().strip('\r\n')

features = PE_Features(pefile_dir)

dataset = features.create_dataset()

print(dataset)
